</div> <div class="footer">Prototype 0.1 — Save/Load via localStorage — Balancing placeholders for rapid iteration.</div> <script> const el = id => document.getElementById(id); const fmt = n => (typeof n === 'number' ? n.toLocaleString() : n); const state = { started: false, week: 0, year: 2025, pop: 10000, money: 0, treasury: 0, price: 1.0, inflationAnn: 0, happiness: 70, market: 'free', // 'free' | 'controlled' skills: { eng:120, bld:400, tch:40, patrols:150 }, rates: { tax:0.10, edu:0.15, def:0.20, wel:0.10 }, refugeesPerMonth: 60, unrest: 0.12, jobsFilled: 0.86, demand: 1.00, supply: 1.00, black: 0.10, auto: null, currency: 'Damscrip', lastPrice: 1.0 }; function log(msg, cls='') { const line = document.createElement('div'); line.className = 'event ' + cls; line.textContent = msg; el('log').prepend(line); } function refresh() { el('modelPill').textContent = state.market === 'free' ? 'Free Market' : 'Controlled'; el('modelPill').className = 'pill ' + (state.market==='free'?'free':'ctrl'); el('pop').textContent = fmt(state.pop); el('money').textContent = fmt(Math.round(state.money)); el('treasury').textContent = fmt(Math.round(state.treasury)); el('inflation').textContent = (state.inflationAnn*100).toFixed(1) + '%'; el('price').textContent = state.price.toFixed(2); el('happiness').textContent = Math.round(state.happiness); el('eng').textContent = state.skills.eng; el('bld').textContent = state.skills.bld; el('tch').textContent = state.skills.tch; el('patrols').textContent = state.skills.patrols; el('refugees').textContent = Math.round(state.refugeesPerMonth); el('jobs').textContent = Math.round(state.jobsFilled*100) + '%'; el('unrest').textContent = Math.round(state.unrest*100) + '%'; el('risk').textContent = state.skills.patrols >= 160 ? 'Low' : state.skills.patrols >= 120 ? 'Moderate' : 'High'; el('demand').textContent = state.demand.toFixed(2); el('supply').textContent = state.supply.toFixed(2); el('black').textContent = state.black < 0.15 ? 'Low' : state.black < 0.35 ? 'Rising' : 'High'; el('week').textContent = state.week; el('year').textContent = state.year; } function startSim() { if (state.started) return; state.started = true; state.currency = el('currencyName').value.trim() || 'Damscrip'; const initial = Math.max(10000, Number(el('initialMoney').value || 1000000)); state.money = initial; state.market = el('marketModel').value; state.lastPrice = state.price; log(`Founded new currency "${state.currency}" with ${fmt(initial)} units.`, 'good'); log(`Market model set to ${state.market}.`, ''); refresh(); } function econTick() { // Weekly tick, derive simple macro // Output: taxes, budgets, inflation proxy, price adjust, population/refugees, skills pipeline, risk/unrest const weeksPerYear = 52; // Taxes on nominal GDP proxy: base economic activity ~ pop * jobsFilled * (market efficiency) const marketEff = state.market === 'free' ? 1.05 : 0.92; const activity = state.pop * state.jobsFilled * marketEff; const price = state.price; const nominal = activity * price; const taxes = nominal * state.rates.tax / weeksPerYear; state.treasury += taxes; // Budgets split tax revenue const eduSpend = taxes * state.rates.edu; const defSpend = taxes * state.rates.def; const welSpend = taxes * state.rates.wel; // Money growth via seigniorage raises inflation const moneyGrowth = (state.money - (state.prevMoney ?? state.money)) / (state.prevMoney || state.money || 1); // Price dynamics: price responds to money growth, demand-supply gap, and market controls const gap = (state.demand - state.supply); const controlDamp = state.market === 'controlled' ? 0.6 : 1.0; const dP = (0.25*moneyGrowth + 0.15*gap) * controlDamp; // per week price change fraction (toy) state.lastPrice = state.price; state.price = Math.max(0.3, state.price * (1 + dP)); // Annualized inflation from weekly price change const weeklyInfl = (state.price / state.lastPrice) - 1; state.inflationAnn = Math.max(-0.5, Math.min(1.5, Math.pow(1 + weeklyInfl, weeksPerYear) - 1)); // Demand/Supply respond to happiness, budgets, and black market const defRiskCut = defSpend > (state.pop*0.01/weeksPerYear) ? 0.01 : 0.0; const blackAdj = state.market === 'controlled' ? 0.01 : -0.005; state.black = Math.max(0, Math.min(0.9, state.black + blackAdj + (gap > 0.1 ? 0.01 : 0))); state.demand = Math.max(0.6, Math.min(1.6, state.demand * (1 + (state.happiness-60)/10000 - weeklyInfl*0.2))); state.supply = Math.max(0.6, Math.min(1.6, state.supply * (1 + (state.jobsFilled-0.8)/20 - state.black*0.01))); // Refugees monthly -> weekly slice const weeklyRef = state.refugeesPerMonth / 4.345; state.pop += Math.round(weeklyRef); // Random skill mix for refugees (toy) if (Math.random() < 0.4) state.skills.bld += 1; if (Math.random() < 0.2) state.skills.eng += 1; if (Math.random() < 0.1) state.skills.tch += 1; // Education pipeline: teachers create future skills but pull from current labor const teacherEffect = Math.min(state.skills.tch, 200) * (eduSpend > 0 ? 0.002 : 0); if (Math.random() < teacherEffect) { // graduate one skilled worker const r = Math.random(); if (r < 0.5) state.skills.bld += 1; else if (r < 0.85) state.skills.eng += 1; else state.skills.tch += 1; log('Education: New skilled worker graduated.', 'good'); } // Teachers reduce current jobsFilled slightly state.jobsFilled = Math.max(0.7, Math.min(0.98, 0.86 - state.skills.tch/10000)); // Risk & unrest const patrolNeed = Math.max(100, Math.floor(state.pop/80)); const risk = Math.max(0, (patrolNeed - state.skills.patrols)/patrolNeed); state.unrest = Math.max(0, Math.min(1, state.unrest + (state.inflationAnn > 0.2 ? 0.01 : -0.002) + (state.market==='free' ? 0.002 : -0.001))); state.happiness = Math.max(10, Math.min(95, state.happiness - (state.inflationAnn>0.2?1.0:0.2) - risk*0.7 + (welSpend>0?0.3:0))); // Zombie incidents if risk high if (Math.random() < risk*0.05) { const loss = Math.floor(5 + Math.random()*20); state.pop = Math.max(0, state.pop - loss); log(`Zombie incident at the perimeter: ${loss} casualties. Increase defense!`, 'bad'); } // Store for next tick state.prevMoney = state.money; state.week += 1; if (state.week % 52 === 0) state.year += 1; refresh(); } function printMoney() { const amt = Number(el('mintAmount').value || 0); if (amt > 0) { state.money += amt; log(`Minted ${fmt(amt)} ${state.currency}.`, 'warn'); refresh(); } } // Actions function buildSchool() { if (state.skills.eng < 1 || state.skills.bld < 3) { log('Construction failed: need 1 engineer and 3 builders.', 'bad'); return; } state.skills.eng -= 1; state.skills.bld -= 3; state.skills.tch += 3; state.treasury = Math.max(0, state.treasury - 2500); log('Built a School: +3 teachers; long‑term skills improved.', 'good'); refresh(); } function buildSewage() { if (state.skills.eng < 2 || state.skills.bld < 5) { log('Construction failed: need 2 engineers and 5 builders.', 'bad'); return; } state.skills.eng -= 2; state.skills.bld -= 5; state.happiness = Math.min(95, state.happiness + 3); state.treasury = Math.max(0, state.treasury - 5000); log('Built Sewage Plant: sanitation improved; +3 happiness.', 'good'); refresh(); } function recruitPatrols() { const hire = 10; state.skills.patrols += hire; state.treasury = Math.max(0, state.treasury - 1000); log(`Recruited ${hire} patrols. Perimeter safety improved.`, 'good'); refresh(); } function openRefuge() { state.refugeesPerMonth = Math.min(300, state.refugeesPerMonth + 40); state.treasury = Math.max(0, state.treasury - 800); log('Refuge program expanded: +40/mo intake. Skills may improve; services load increases.', ''); refresh(); } // Wire UI el('startBtn').onclick = startSim; el('tickBtn').onclick = () => { if (state.started) econTick(); }; el('runBtn').onclick = () => { if (!state.started) return; if (state.auto) { clearInterval(state.auto); state.auto = null; el('runBtn').textContent = 'Auto‑Run'; } else { state.auto = setInterval(econTick, 600); el('runBtn').textContent = 'Pause'; } }; el('mintBtn').onclick = printMoney; el('taxRate').oninput = e => { const v = Number(e.target.value); state.rates.tax = v/100; el('taxRateVal').textContent = `${v}%`; }; el('eduBud').oninput = e => { el('eduBudVal').textContent = `${e.target.value}%`; state.rates.edu = Number(e.target.value)/100; }; el('defBud').oninput = e => { el('defBudVal').textContent = `${e.target.value}%`; state.rates.def = Number(e.target.value)/100; }; el('welBud').oninput = e => { el('welBudVal').textContent = `${e.target.value}%`; state.rates.wel = Number(e.target.value)/100; }; el('buildSchool').onclick = buildSchool; el('buildSewage').onclick = buildSewage; el('recruitPatrols').onclick = recruitPatrols; el('openRefuge').onclick = openRefuge; el('currencyName').value = state.currency; el('marketModel').onchange = e => { state.market = e.target.value; refresh(); }; // Save/Load el('saveBtn').onclick = () => { localStorage.setItem('trace_money_state', JSON.stringify(state)); log('Game saved locally.', 'good'); }; el('loadBtn').onclick = () => { const raw = localStorage.getItem('trace_money_state'); if (!raw) return log('No save found.', 'bad'); const s = JSON.parse(raw); // Preserve functions and defaults Object.assign(state, s); refresh(); log('Save loaded.', 'good'); }; el('resetBtn').onclick = () => { localStorage.removeItem('trace_money_state'); location.reload(); }; // Initial paint refresh(); </script> </body> </html> ```